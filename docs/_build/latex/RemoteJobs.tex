% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Remote Jobs Documentation}
\date{February 22, 2012}
\release{0.1}
\author{Troels F. RÃ¸nnow}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction:welcome-to-the-batchq-documentation}\label{introduction::doc}
BatchQ is a set of classes written in Python which aims towards
automating all kinds of task. BatchQ was designed for interacting with
terminal application including Bash, SSH, SFTP, Maple, Mathematica,
Octave, Python and more. If for one or another reason your favorite
application is not supported BatchQ is easily extended to support more
programs.


\section{Dependencies and Compatibility}
\label{introduction:dependencies-and-compatibility}
Currently BatchQ only depends on the libraries shipped with Python. It
should therefore work out of the box.

Please note that at the present moment BatchQ has only been tested with
Python 2.7 on Mac OS X 10.6 and with Python 2.6.5 on Ubuntu 10.10.


\section{Installation}
\label{introduction:installation}
There are currently two ways of installing BatchQ. Either you use setup
tools in which case you write

\begin{Verbatim}[commandchars=\\\{\}]
easy\PYGZus{}install batchq
\end{Verbatim}

Alternatively you can download the latest version from GitHub and
install using setup.py

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYG{o}{[}location/of/source\PYG{o}{]}
python setup.py install
\end{Verbatim}

That's it.


\section{Note for Windows users}
\label{introduction:note-for-windows-users}
This version of BatchQ is not yet supported on Windows
platforms. Developers are encouraged to extend the \code{Process}
module. Unfortunately, it seems that it is not possible to create a
pure Python solution and a terminal module should be written in C/C++.

For information on the structure of the code please consult the
developers introduction.


\chapter{Users Guide}
\label{user/intro:users-guide}\label{user/intro::doc}

\section{Using the command line tool}
\label{user/intro:using-the-command-line-tool}

\subsection{Available modules}
\label{user/intro:available-modules}
The modules available to BatchQ will vary from system to system
depending on whether custom modules have been installed. Modules are
divided into four categories: functions, queues, pipelines and
templates.
The general syntax of the Q command is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q \PYG{o}{[}\PYG{k}{function}/queue/template\PYG{o}{]} \PYG{o}{[}arguments\PYG{o}{]}
\end{Verbatim}

The following functions are available through the console interface and
using Python and are standard modules included in BatchQ which provides
information about other modules
\index{list() (in module batchq.queues.nohup)}

\begin{fulllineitems}
\phantomsection\label{user/intro:batchq.queues.nohup.list}\pysiglinewithargsret{\code{batchq.queues.nohup.}\bfcode{list}}{\emph{module}, \emph{*args}, \emph{**kwargs}}{}
To list the available modules type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q list \PYG{o}{[}argument\PYG{o}{]}
\end{Verbatim}

The optional list argument should be either of module classes (in
plural): functions, queues, pipelines or templates, i.e.,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q list functions

Available functions:
  configuration
  list
  \PYG{n+nb}{help}
\end{Verbatim}

The list command can also be used without argument in which case it
produces a list of all available modules.

Note this function is not intended for Python use. Insted import
\code{batchq.core.library.Library} and access the members
\code{functions}, \code{queues}, \code{templates} and \code{pipelines}.

\end{fulllineitems}

\index{help() (in module batchq.queues.nohup)}

\begin{fulllineitems}
\phantomsection\label{user/intro:batchq.queues.nohup.help}\pysiglinewithargsret{\code{batchq.queues.nohup.}\bfcode{help}}{\emph{name}, \emph{*args}, \emph{**kwargs}}{}
The help function provides information, if available, about how a
module is used. The help function is invoked by writing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q \PYG{n+nb}{help} \PYG{o}{[}module name\PYG{o}{]}
\end{Verbatim}

Writing

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q \PYG{n+nb}{help }\PYG{n+nb}{help}
\end{Verbatim}

gives information about the help module (i.e. the information you
are reading now).

\end{fulllineitems}



\subsection{Submitting jobs}
\label{user/intro:submitting-jobs}
The BatchQ command line interface provides you with two predefined
submission modules: nohup and lsf. Nohup is available on every


\subsection{Creating configuration files}
\label{user/intro:creating-configuration-files}
Once you have automated the submission process you want to store the
configuration parameters in a file in order to shorten the commands need
to operate on your submissions. Using the example from before, this can
be done as

\begin{Verbatim}[commandchars=\\\{\}]
q configuration brutus -i --username\PYG{o}{=}user --working\PYGZus{}directory\PYG{o}{=}\PYG{l+s+s2}{"Submission"} --command\PYG{o}{=}\PYG{l+s+s2}{"./script"} --input\PYGZus{}directory\PYG{o}{=}\PYG{l+s+s2}{"."} --port\PYG{o}{=}22 --server\PYG{o}{=}\PYG{l+s+s2}{"server.address.com"}
\end{Verbatim}

The above code creates a configuration named ``brutus'' which contains the instructions for submitting your job on ``server.address.com''.
Having created a configuration file you can now submit jobs and check status with

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q lsf submit@brutus
True
\PYG{n+nv}{\PYGZdl{} }q lsf pid@brutus
12452
\end{Verbatim}

This keeps things short and simple. You will need to create a
configuration file for each server you want to submit your job. If for
one or another reason you temporarily want to change parameters of your
configuration, say the \code{working\_directory}, this can be done by adding
a long parameter:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }q lsf submit@brutus --working\PYGZus{}directory\PYG{o}{=}\PYG{l+s+s2}{"Submission2"}
True
\end{Verbatim}


\subsection{Retrieving results}
\label{user/intro:retrieving-results}

\subsection{Example: Submitting ALPS jobs using nohup}
\label{user/intro:example-submitting-alps-jobs-using-nohup}

\subsection{Example: Submitting ALPS jobs using LSF}
\label{user/intro:example-submitting-alps-jobs-using-lsf}

\section{Using Python}
\label{user/intro:using-python}

\subsection{Submitting jobs}
\label{user/intro:id1}

\subsection{Retrieving results}
\label{user/intro:id2}

\subsection{Example: Submitting ALPS jobs using nohup}
\label{user/intro:id3}

\subsection{Example: Submitting ALPS jobs using LSF}
\label{user/intro:id4}

\section{Using VisTrails}
\label{user/intro:using-vistrails}

\subsection{Submitting jobs}
\label{user/intro:id5}

\subsection{Retrieving results}
\label{user/intro:id6}

\subsection{Example: Submitting ALPS jobs using nohup}
\label{user/intro:id7}

\subsection{Example: Submitting ALPS jobs using LSF}
\label{user/intro:id8}

\chapter{Developer: Getting started}
\label{tutorial:developer-getting-started}\label{tutorial::doc}
The following section is meant as an instructive example of how BatchQ
can be used to automate simple tasks such as logging on to a server and
creating a configuration file. This first section is somewhat basic
stuff, but important, nevertheless, since BatchQ is designed to be
different from your normal Python programs in its structure. All the key
classes are shortly described here.

Imagine that you want to open Bash, go to  Documents in your home folder
and create a text file. With Bash commands for this would be

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}/Documents
\PYG{n+nb}{echo }Hello world \textgreater{} hello.txt
\end{Verbatim}

In this tutorial we will automate this task. If you are eager to use
BatchQ and do not really care about the
underlying functionality you probably should skip right away to one of
the examples of job automation:
\begin{enumerate}
\item {} 
{\hyperref[tutorial:example-createfile1]{\emph{Example: CreateFile}}}

\item {} 
{\hyperref[tutorial:example-createfile2]{\emph{Example: CreateFileAndDirectory}}}

\item {} 
{\hyperref[tutorial:example-createfile3]{\emph{Example: CreateFileSSH}}}

\end{enumerate}

However, it is strongly recommended that you go through all the examples
to get a basic understanding of the structure of BacthQ, how it works
and what you can do with it.


\section{Processes and Pipes}
\label{tutorial:processes-and-pipes}
While it is not necessary to understand the concepts of Processes and
Pipes in order to use BatchQ, it surely is useful in order to get a
picture of the whole structure of this package.
If you are familiar with \emph{Pexpect \textless{}http://www.noah.org/wiki/pexpect\textgreater{}}
you are already familiar with some of the key concepts of BatchQ. BatchQ
provides a classes which have some similarities with Pexpect, yet
differs in a number of ways, the most significant being that BatchQ
communication with the terminal and expect functionality has been
seperated into two classes: Process and BasePipe. The Process class
provides methods for communicating directly with a process with no
intepretation of the output, whereas BasePipe implements output
interpretation and expect functionality.

Unlike Pexpect, Process does not apply which on the command passed as
the constructor argument and this command must be applied manually. In
the following example we open a instance of Bash writes ``echo Hello
world'' and read the output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core.process} \PYG{k+kn}{import} \PYG{n}{Process}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core.utils} \PYG{k+kn}{import} \PYG{n}{which}

\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Starting bash found at}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{which}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{bash}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{which}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{bash}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Waits until we have the prompt}
\PYG{k}{while} \PYG{n}{x}\PYG{o}{.}\PYG{n}{getchar}\PYG{p}{(}\PYG{p}{)} \PYG{o}{!=} \PYG{l+s}{"}\PYG{l+s}{\PYGZdl{}}\PYG{l+s}{"}\PYG{p}{:} \PYG{k}{pass}

\PYG{c}{\PYGZsh{} Sends a command to the terminal}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{echo Hello world}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}\PYG{p}{)}

\PYG{c}{\PYGZsh{} And read the response}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{"}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{The response is:}\PYG{l+s}{"}
\PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{"}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{The full buffer is:}\PYG{l+s}{"}
\PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{buffer}
\PYG{n}{x}\PYG{o}{.}\PYG{n}{kill}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This code produces following output

\begin{Verbatim}[commandchars=\\\{\}]
Starting bash found at /bin/bash

The response is:
 echo Hello world
Hello world
bash-3.2\$ 

The full buffer is:
[?1034hbash-3.2\$ echo Hello world
Hello world
bash-3.2\$
\end{Verbatim}

Here we are essentially communicating with the process at the most basic
level and we have to interpret every character returned. Especially, it
should be noted that escape characters are not interpreted in any way
and also that the response from x.read() contains the echo of the
command. Both of these features are somewhat inconvenient when ones to
communicate with a process.

The BasePipe class overcome the inconvenience of the Process class by
implementing expect

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core.process} \PYG{k+kn}{import} \PYG{n}{Process}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core.communication} \PYG{k+kn}{import} \PYG{n}{BasePipe}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core.utils} \PYG{k+kn}{import} \PYG{n}{which}

\PYG{k}{class} \PYG{n+nc}{BashTerminal}\PYG{p}{(}\PYG{n}{BasePipe}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{pipe} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{which}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{bash}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{,} \PYG{n}{terminal\PYGZus{}required} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}
        \PYG{n}{expect\PYGZus{}token} \PYG{o}{=}\PYG{l+s}{"}\PYG{l+s}{\PYGZsh{}--\textgreater{}}\PYG{l+s}{"}
        \PYG{n}{submit\PYGZus{}token} \PYG{o}{=}\PYG{l+s}{"}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{"}
        \PYG{n}{initiate\PYGZus{}pipe}\PYG{o}{=}\PYG{n+nb+bp}{True}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{BashTerminal}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{pipe}\PYG{p}{,} \PYG{n}{expect\PYGZus{}token}\PYG{p}{,} \PYG{n}{submit\PYGZus{}token}\PYG{p}{,} \PYG{n}{initiate\PYGZus{}pipe}\PYG{p}{)}        


    \PYG{k}{def} \PYG{n+nf}{initiate\PYGZus{}pipe}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pipe}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{export PS1=}\PYG{l+s+se}{\PYGZbs{}"}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}"}\PYG{l+s}{"} \PYG{o}{\PYGZpc{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}expect\PYGZus{}token}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{consume\PYGZus{}output}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{pipe}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}submit\PYGZus{}token}\PYG{p}{)}  
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{consume\PYGZus{}output}\PYG{p}{(}\PYG{p}{)}
    
    \PYG{k}{def} \PYG{n+nf}{echo}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{echo }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{"}\PYG{o}{\PYGZpc{}}\PYG{n}{msg}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{BashTerminal}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Response: }\PYG{l+s}{"}
\PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{echo}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello world}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{"}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{VT100 Buffer:}\PYG{l+s}{"}
\PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{buffer}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{"}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Pipe Buffer:}\PYG{l+s}{"}
\PYG{k}{print} \PYG{n}{x}\PYG{o}{.}\PYG{n}{pipe\PYGZus{}buffer}
\end{Verbatim}

which produces

\begin{Verbatim}[commandchars=\\\{\}]
Response: 
Hello world


VT100 Buffer:
export PS1="\#--\textgreater{}"bash-3.2\$ export PS1="\#--\textgreater{}"
\#--\textgreater{}echo Hello world
Hello world
\#--\textgreater{}

Pipe Buffer:
export PS1="\#--\textgreater{}"[?1034hbash-3.2\$ export PS1="\#--\textgreater{}"
\#--\textgreater{}echo Hello world
Hello world
\#--\textgreater{}
\end{Verbatim}

The properties pipe and pipe\_buffer are references to the Process object
and the Process.buffer, respectively. As with the first example we see
that the process buffer contains VT100 characters. However, the BasePipe
uses a VT100 interpreter to ensure that the output in BasePipe.buffer
looks like what you would see if you where interacting with a terminal
yourself. This is important as it eases the development process of
pipelines.

The separation of Process and BasePipe ensures that unsupported
platforms in the future can be supported. In order to make BatchQ work
on unsupported system (i.e. Windows at the moment) one has to write a
new Process module for the platform. Once a Process class exists
BasePipe implements all the features needed to efficiently communicate
with an instance of a process.


\subsection{Pipelines}
\label{tutorial:pipelines}
Pipelines are subclasses of BasePipe which are intended for a specific
program like the example in the previous section. BatchQ is shipped with
many different pipelines found in batchq.pipelines which among others
contain BashTerminal, SSHTerminal and SFTPTerminal. The SSHTerminal
subclasses BashTerminal and replaces the process instance with an SSH
instance. This in term means that any program written for BashTerminal
works with SSHTerminal which is handy as you might want to develop a
program locally and once working, deploy it using SSH.

We are going to give an example of how this is done in the following
code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.bash} \PYG{k+kn}{import} \PYG{n}{BashTerminal}

\PYG{k}{class} \PYG{n+nc}{CreateFileBash}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{directory}\PYG{p}{,} \PYG{n}{command}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{directory} \PYG{o}{=} \PYG{n}{directory}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{command} \PYG{o}{=} \PYG{n}{command}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal} \PYG{o}{=} \PYG{n}{BashTerminal}\PYG{p}{(}\PYG{p}{)}        

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}dir}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{home} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{home}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{home}\PYG{p}{)}

        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{directory}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{directory}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{)}
        
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{directory}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb+bp}{self}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}file}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{create\PYGZus{}dir}\PYG{p}{(}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{command}\PYG{p}{)}
        \PYG{k}{return} \PYG{n+nb+bp}{self}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s}{"}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{n}{instance} \PYG{o}{=} \PYG{n}{CreateFileBash}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Documents/DEMO\PYGZus{}Bash}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{echo hello new directory \textgreater{} hello.txt}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{instance}\PYG{o}{.}\PYG{n}{command} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{echo Hello Python world \textgreater{} hello.txt}\PYG{l+s}{"}
    \PYG{n}{instance}\PYG{o}{.}\PYG{n}{create\PYGZus{}file}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

With this code we have solved the initial problem, and moreover, the
code is easily extended to support SSH by subclasssing
CreateFileBash and replacing the terminal:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.ssh} \PYG{k+kn}{import} \PYG{n}{SSHTerminal}

\PYG{k}{class} \PYG{n+nc}{CreateFileSSH}\PYG{p}{(}\PYG{n}{CreateFileBash}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{directory}\PYG{p}{,} \PYG{n}{command}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{n}{username}\PYG{p}{,} \PYG{n}{password}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{terminal} \PYG{o}{=} \PYG{n}{SSHTerminal}\PYG{p}{(}\PYG{n}{server}\PYG{p}{,} \PYG{n}{username}\PYG{p}{,} \PYG{n}{password}\PYG{p}{)}        
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{n}{CreateFileSSH}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{,} \PYG{n}{command}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{o}{==}\PYG{l+s}{"}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{"}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{getpass}
    \PYG{n}{user} \PYG{o}{=} \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Username:}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{pasw} \PYG{o}{=} \PYG{n}{getpass}\PYG{o}{.}\PYG{n}{getpass}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{instance} \PYG{o}{=} \PYG{n}{CreateFileSSH}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Documents/DEMO\PYGZus{}SSH}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{echo Hello SSH \textgreater{} hello.txt}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{localhost}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{user}\PYG{p}{,}\PYG{n}{pasw}\PYG{p}{)}
    \PYG{n}{instance}\PYG{o}{.}\PYG{n}{create\PYGZus{}file}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This clearly demonstrates the power of using a standards for the various
terminal implementations. The function calls used here would be also be
possible to implement on a Windows machine, and thus, in this way we
have a universal script that works independent of the system it is
on.


\section{BatchQ Basics}
\label{tutorial:batchq-basics}
Next to the pipelines and processes, the BatchQ module contains
five other important classes: BatchQ, WildCard, Property, Controller and
Function.
BatchQ is the general model which your class should inherit. It provides
the functionality for manging pipelines, properties, and function
queues. In short, any BatchQ script is a class that subclasses BatchQ
and have one or more of WildCard, Property, Controller and
Function defined. The general structure of a BatchQ class is

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{SubmissionModel}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{param1} \PYG{o}{=} \PYG{n}{Property}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{default value 1}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{param2} \PYG{o}{=} \PYG{n}{Property}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{default value 2}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} ...}

    \PYG{n}{terminal1} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Class1}\PYG{p}{,} \PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
    
    \PYG{n}{t1\PYGZus{}fnc1} \PYG{o}{=} \PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{a}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{b}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{t1\PYGZus{}fnc2} \PYG{o}{=} \PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{c}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{d}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} ...}

    \PYG{n}{terminal2} \PYG{o}{=} \PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Class2}\PYG{p}{,} \PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}

    \PYG{n}{t2\PYGZus{}fnc1} \PYG{o}{=} \PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{e}\PYG{p}{(}\PYG{n}{param1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{f}\PYG{p}{(}\PYG{n}{param2}\PYG{p}{)}
    \PYG{n}{t2\PYGZus{}fnc2} \PYG{o}{=} \PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{g}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{h}\PYG{p}{(}\PYG{p}{)}
    \PYG{c}{\PYGZsh{} ...}

    \PYG{k}{def} \PYG{n+nf}{userdef1}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} ...}
        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{userdef2}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} ...}
        \PYG{k}{pass}
\end{Verbatim}

Properties are input parameters for the automation model you are
creating, controllers are pipeline holders and functions are queues of
function calls that will be invoked on the class through the
controller. Thus, calling \code{SubmissionModel().t1\_fnc2()} would result in
two function calls: \code{instance.a()} and \code{instance.b()} with
\code{instance = Class1(arg1, arg2, ...)}. It is possible to use
the parameters as function arguments as done in line 14. Upon
realisation of the function calls \code{param1} and \code{param2} are
fetched. They may be changed using the normal assignment operator before
the function call to change their value. Get an idea how this works we
will in the following go through some simple examples.


\subsection{Example: Hello world}
\label{tutorial:example-hello-world}
In this example we demonstrate how a function queue is invoked on the
pipeline:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k}{class} \PYG{n+nc}{Pipeline}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hello world}\PYG{l+s}{"}

    \PYG{k}{def} \PYG{n+nf}{hello\PYGZus{}batchq}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hello BatchQ}\PYG{l+s}{"}

\PYG{k}{class} \PYG{n+nc}{HelloWorld}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipeline}\PYG{p}{)}
    \PYG{n}{fnc} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello\PYGZus{}batchq}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{instance} \PYG{o}{=} \PYG{n}{HelloWorld}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This code results in following output

\begin{Verbatim}[commandchars=\\\{\}]
Hello world
Hello BatchQ
\end{Verbatim}

What happens is:
\begin{enumerate}
\item {} 
A controller is defined which creates an instance \code{pipe} of the
Pipeline class.

\item {} 
Next a function \code{fnc} is defined as the sequence of function calls
''.hello\_world(), .hello\_batchq()''

\item {} 
When \code{fnc} is called two function calls, \code{pipe.hello\_world()} and
\code{pipe.hello\_batchq()} are made.

\end{enumerate}

It is worth noting that the function queue is abstract, meaning that the
queue accept any calls - errors will first occur when \code{instance.fnc()}
is called.


\subsection{Example: Hello parameter}
\label{tutorial:example-hello-parameter}
Next we extend the previous program introducing a parameter

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k}{class} \PYG{n+nc}{Pipeline}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{hello}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{who}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hello}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{who}


\PYG{k}{class} \PYG{n+nc}{HelloParam}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{message} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Parameter}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipeline}\PYG{p}{)}
    \PYG{n}{fnc} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}

\PYG{n}{HelloParam}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ins1} \PYG{o}{=} \PYG{n}{HelloParam}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Second Instance}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{ins2} \PYG{o}{=} \PYG{n}{HelloParam}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ins2}\PYG{o}{.}\PYG{n}{message} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Property}\PYG{l+s}{"}
\PYG{n}{ins2}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ins1}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Three lines of output are produces here:

\begin{Verbatim}[commandchars=\\\{\}]
Hello Parameter
Hello Property
Hello Second Instance
\end{Verbatim}

each corresponding to a call to \code{fnc()}. This code shows how a
parameter can be passed on to a function call. It is important to notice
that the parameter can be changed even after creating an instance of an
object and that properties are \emph{not} static members of the class,
i.e. different instances may have different values. Finally, it is worth
noticing that properties becomes constructor arguments of the BatchQ
subclass.


\subsection{Example: Hello error I}
\label{tutorial:example-hello-error-i}
The default of BatchQ is that all errors raised are suppressed by the
Function queue. You can, however, force BatchQ to raise errors by
setting the parameter \code{verbose} of the function object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k}{class} \PYG{n+nc}{ErrorTest}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello error}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{False}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello\PYGZus{}world}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello error}\PYG{l+s}{"}\PYG{p}{)}

\PYG{n}{instance} \PYG{o}{=} \PYG{n}{ErrorTest}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{instance}\PYG{o}{.}\PYG{n}{fnc1}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{An error occured in fnc1}\PYG{l+s}{"}
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{instance}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{An error occured in fnc2}\PYG{l+s}{"}
\end{Verbatim}


\subsection{Example: Hello error II}
\label{tutorial:example-hello-error-ii}
The BatchQ function also is given the possibility to raise errors. It is
done in the following way:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}

\PYG{k}{class} \PYG{n+nc}{Model}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Qthrow}\PYG{p}{(}\PYG{n}{exception} \PYG{o}{=} \PYG{n+ne}{StandardError}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Custom error class}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Qthrow}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Standard error}\PYG{l+s}{"}\PYG{p}{)}

\PYG{n}{Model}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc1}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Model}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The \code{throw} function ignores the \code{verbose} option on the \code{Function}
object and is always thrown.


\subsection{Example: Function Inheritance}
\label{tutorial:example-function-inheritance}
Common jobs such as changing into a working directory is often done in
several procedures when making a batch script. For this reason BatchQ
allows you to inherit earlier defined functions

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}

\PYG{k}{class} \PYG{n+nc}{Pipe}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{display}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{msg}

\PYG{k}{class} \PYG{n+nc}{Inherits}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipe}\PYG{p}{)}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello world}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{fnc1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello world II}\PYG{l+s}{"}\PYG{p}{)}

\PYG{n}{Inherits}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Upon inheritance the entire queue from \code{fnc1} is copied meaning that
the result stack of \code{fnc1} is not populated as it would have been with
a function call.


\subsection{Example: Function Calls}
\label{tutorial:example-function-calls}
Often it is useful to divide jobs into subprocedures. For this purpose
it can often be necessary to do function calls. Function calls are also
allowed with  BatchQ

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}

\PYG{k}{class} \PYG{n+nc}{Pipe}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{display}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{msg}
        \PYG{k}{return} \PYG{n}{msg}

\PYG{k}{class} \PYG{n+nc}{CallIt1}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipe}\PYG{p}{)}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello world}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Before call}\PYG{l+s}{"}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Qcall}\PYG{p}{(}\PYG{n}{fnc1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{After call}\PYG{l+s}{"}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{Qprint\PYGZus{}stack}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{CallIt1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{"}

\PYG{k}{class} \PYG{n+nc}{CallIt2}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipe}\PYG{p}{)}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello world}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Qjoin}\PYG{p}{(}\PYG{n}{fnc1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{ II}\PYG{l+s}{"}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{)}

\PYG{n}{CallIt2}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

One important thing to note here is that it is the Function object that
is passed on as argument and not Function(). The reason is that we are
creating a reference model, the queue, and not performing an actual call
during the construction of the class.


\subsection{Wildcards}
\label{tutorial:wildcards}
TODO: Explain the concept of a wildcard

In the following example we define five different wild cards.
The first wildcard \_ pops the result stack and the second \_r pops the
result stack in reverse order - that is, if \_, \_ produces ``a'', ``b'', then
\_r, \_r produces ``b'',''a''.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}

\PYG{k}{class} \PYG{n+nc}{TestPipe4}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{fnc1} \PYG{o}{=} \PYG{k}{lambda} \PYG{n+nb+bp}{self}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Function 1}\PYG{l+s}{"}
    \PYG{n}{fnc2} \PYG{o}{=} \PYG{k}{lambda} \PYG{n+nb+bp}{self}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Function 2}\PYG{l+s}{"}
    \PYG{n}{fnc3} \PYG{o}{=} \PYG{k}{lambda} \PYG{n+nb+bp}{self}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Function 3}\PYG{l+s}{"}
    \PYG{n}{fnc4} \PYG{o}{=} \PYG{k}{lambda} \PYG{n+nb+bp}{self}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Function 4}\PYG{l+s}{"}
    \PYG{n}{fnc5} \PYG{o}{=} \PYG{k}{lambda} \PYG{n+nb+bp}{self}\PYG{p}{:} \PYG{l+s}{"}\PYG{l+s}{Function 5}\PYG{l+s}{"}

    \PYG{k}{def} \PYG{n+nf}{display}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{1: }\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{msg}
        \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s}{Display function I}\PYG{l+s}{"}

    \PYG{k}{def} \PYG{n+nf}{display2}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg1}\PYG{p}{,} \PYG{n}{msg2}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{2: }\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{msg1}\PYG{p}{,} \PYG{n}{msg2}
        \PYG{k}{return} \PYG{l+s}{"}\PYG{l+s}{Display Function II}\PYG{l+s}{"}


\PYG{k}{class} \PYG{n+nc}{Q6}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{\PYGZus{}r} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{n}{reverse} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n}{\PYGZus{}l} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{n}{lifo} \PYG{o}{=} \PYG{n+nb+bp}{False}\PYG{p}{)}
    \PYG{n}{\PYGZus{}lr} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{n}{lifo} \PYG{o}{=} \PYG{n+nb+bp}{False}\PYG{p}{,} \PYG{n}{reverse} \PYG{o}{=} \PYG{n+nb+bp}{True}\PYG{p}{)}
    \PYG{n}{\PYGZus{}3} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{n}{select} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}

    \PYG{n}{pipe} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{TestPipe4}\PYG{p}{)}

    \PYG{n}{call\PYGZus{}fnc} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{fnc1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc2}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc3}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{fnc4}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc5}\PYG{p}{(}\PYG{p}{)} 

    \PYG{n}{test1} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{)}
    \PYG{n}{test2} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display2}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{p}{)}
    \PYG{n}{test3} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display2}\PYG{p}{(}\PYG{n}{\PYGZus{}r}\PYG{p}{,}\PYG{n}{\PYGZus{}r}\PYG{p}{)}
    \PYG{n}{test4} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display2}\PYG{p}{(}\PYG{n}{\PYGZus{}l}\PYG{p}{,}\PYG{n}{\PYGZus{}l}\PYG{p}{)}
    \PYG{n}{test5} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display2}\PYG{p}{(}\PYG{n}{\PYGZus{}lr}\PYG{p}{,}\PYG{n}{\PYGZus{}lr}\PYG{p}{)}
    \PYG{n}{test6} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{call\PYGZus{}fnc}\PYG{p}{)}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{n}{\PYGZus{}3}\PYG{p}{)}


\PYG{n}{instance} \PYG{o}{=} \PYG{n}{Q6}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test1}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test2}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test3}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test4}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test5}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{test6}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsection{Example: CreateFile}
\label{tutorial:example-createfile1}\label{tutorial:example-createfile}
At this point we have significantly insight into the structure of BatchQ
to write a realisation of the initial problem: creating a script that
creates a directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.bash} \PYG{k+kn}{import} \PYG{n}{BashTerminal}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.ssh} \PYG{k+kn}{import} \PYG{n}{SSHTerminal}

\PYG{k}{class} \PYG{n+nc}{CreateFile1}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{p}{)}

  \PYG{n}{directory} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
  \PYG{n}{command} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}

  \PYG{n}{terminal} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Pipeline}\PYG{p}{(}\PYG{n}{BashTerminal}\PYG{p}{)}

  \PYG{n}{create\PYGZus{}file} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
      \PYG{o}{.}\PYG{n}{home}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{)} \PYGZbs{}
      \PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}

  \PYG{n}{instance} \PYG{o}{=} \PYG{n}{CreateFile1}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Documents}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{echo hello world \textgreater{} hello.txt}\PYG{l+s}{"}\PYG{p}{)}
  \PYG{n}{instance}\PYG{o}{.}\PYG{n}{create\PYGZus{}file}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

While this code is short and very easy to read, it obviously have shortcomings:
The code will fail if the directory does not already exist. In order to
resolve this issue we need to use some built-in functions to do simple
if statements.


\subsection{Built-in Do-function}
\label{tutorial:built-in-do-function}

\subsection{Example: CreateFileAndDirectory}
\label{tutorial:example-createfile2}\label{tutorial:example-createfileanddirectory}
With the \code{do} we can now extend our previous script and ensure that
the directory is created if it does not exist:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.bash} \PYG{k+kn}{import} \PYG{n}{BashTerminal}

\PYG{k}{class} \PYG{n+nc}{CreateFileAndDirectory}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{directory} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{command} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{terminal} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{BashTerminal}\PYG{p}{)}

    \PYG{n}{create\PYGZus{}dir} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{home}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{\PYGZus{}}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}\PYG{o}{.}\PYG{n}{Qdon}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{,} \PYG{n+nb+bp}{True}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{chdir}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{)}
    
    \PYG{n}{create\PYGZus{}file} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{create\PYGZus{}dir}\PYG{p}{)} \PYGZbs{}
        \PYG{o}{.}\PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
\end{Verbatim}


\subsection{Example: Short version}
\label{tutorial:example-short-version}
While the previous code is pretty taking into consideration what it
does it can still be made shorter. One of the neat features of function
queues are that you can predefine certain patterns - as for instance
creating a directory in your home directory:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.bash} \PYG{k+kn}{import} \PYG{n}{BashTerminal}
\PYG{k+kn}{from} \PYG{n+nn}{batchq.shortcuts.shell} \PYG{k+kn}{import} \PYG{n}{home\PYGZus{}create\PYGZus{}dir}\PYG{p}{,} \PYG{n}{send\PYGZus{}command}

\PYG{k}{class} \PYG{n+nc}{CreateFileShort}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{WildCard}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{directory} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{command} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{terminal} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{BashTerminal}\PYG{p}{)}

    \PYG{n}{create\PYGZus{}dir} \PYG{o}{=} \PYG{n}{home\PYGZus{}create\PYGZus{}dir}\PYG{p}{(}\PYG{n}{directory}\PYG{p}{,}\PYG{n}{\PYGZus{}}\PYG{p}{)}
    \PYG{n}{create\PYGZus{}file} \PYG{o}{=} \PYG{n}{send\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{,} \PYG{n}{inherits} \PYG{o}{=} \PYG{n}{create\PYGZus{}dir}\PYG{p}{)}
\end{Verbatim}


\subsection{Overwriting Controllers}
\label{tutorial:overwriting-controllers}
A key feature of BatchQ is that you can overwrite controllers from your
previous models. This means that once you have made a model for one
pipeline you can use it on another one by simply overwriting the
controller. In the following we overwrite the controller for one
pipeline with a new controller for another pipeline:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.core} \PYG{k+kn}{import} \PYG{n}{batch}

\PYG{k}{class} \PYG{n+nc}{Pipe}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{hello}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{msg}

\PYG{k}{class} \PYG{n+nc}{Model1}\PYG{p}{(}\PYG{n}{batch}\PYG{o}{.}\PYG{n}{BatchQ}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{Pipe}\PYG{p}{)}
    \PYG{n}{fnc} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Function}\PYG{p}{(}\PYG{n}{verbose}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}\PYG{o}{.}\PYG{n}{hello}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Hello from FNC}\PYG{l+s}{"}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{ReplacementPipe}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{hello}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{msg}\PYG{p}{)}\PYG{p}{:}       
        \PYG{k}{print} \PYG{n}{msg}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{-}\PYG{l+m+mi}{1}\PYG{p}{]}

\PYG{k}{class} \PYG{n+nc}{Model2}\PYG{p}{(}\PYG{n}{Model1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ctrl} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{ReplacementPipe}\PYG{p}{)}

\PYG{n}{Model1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Model2}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{fnc}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The replacement pipeline reverses the string and the code produces the
following output

\begin{Verbatim}[commandchars=\\\{\}]
Hello from FNC
CNF morf olleH
\end{Verbatim}


\subsection{Example: CreateFileSSH}
\label{tutorial:example-createfilessh}\label{tutorial:example-createfile3}
Clearly, the previous example comes in handy when we want to extent our
script to support SSH:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{batchq.pipelines.shell.ssh} \PYG{k+kn}{import} \PYG{n}{SSHTerminal}
\PYG{k+kn}{import} \PYG{n+nn}{getpass}

\PYG{k}{class} \PYG{n+nc}{CreateFileSSH}\PYG{p}{(}\PYG{n}{CreateFileShort}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{server} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{username} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{password} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Property}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{terminal} \PYG{o}{=} \PYG{n}{batch}\PYG{o}{.}\PYG{n}{Controller}\PYG{p}{(}\PYG{n}{SSHTerminal}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{n}{username}\PYG{p}{,} \PYG{n}{password}\PYG{p}{)}

\PYG{n}{user} \PYG{o}{=} \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Username:}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{pasw} \PYG{o}{=} \PYG{n}{getpass}\PYG{o}{.}\PYG{n}{getpass}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{instance} \PYG{o}{=} \PYG{n}{CreateFileSSH}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Documents/DEMO\PYGZus{}SSH}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{echo Hello SSH \textgreater{} hello.txt}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{localhost}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{user}\PYG{p}{,}\PYG{n}{pasw}\PYG{p}{)}
\PYG{n}{instance}\PYG{o}{.}\PYG{n}{create\PYGZus{}file}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The three new properties are appended to the constructor arguments.


\chapter{Tutorial: nohup Remote Submission}
\label{tutorial_nhup:tutorial-nohup-remote-submission}\label{tutorial_nhup::doc}
In this tutorial we are going to write a submission module using
nohup. Actually, we will not use nohup itself as this is a rather
unstable application, but instead we will use the bash equivalent
\code{({[}command{]} )} as this is a much more stable method.


\section{Basic functionality}
\label{tutorial_nhup:basic-functionality}
By now we have already written the first many small classes using
BatchQ and therefore, the only thing we really need to know is which
parameters the class should depend on and which methods we should
implement.

A nohup module should take a command as input
parameter as well as a working directory. It should implement the
methods startjob, isrunning and clean. Subsequently, these function
would need a function that enters the working directory and a function
that checks whether a process is running. The implementation is straight
forward:

\begin{Verbatim}[commandchars=\\\{\}]
from batchq.core.library import Library
from batchq.core import batch
from batchq.pipelines.shell.bash import BashTerminal
from batchq.shortcuts.shell import home\_create\_dir, send\_command

class NoHUPStart(batch.BatchQ):
    \_r = batch.WildCard(reverse = True)
    \_ = batch.WildCard()

    input\_directory = batch.Property()
    working\_directory = batch.Property()
    command = batch.Property()

    terminal = batch.Controller(BashTerminal)

    workdir = batch.Function() \PYGZbs{}
        .home().chdir(\_).exists(working\_directory) \PYGZbs{}
        .don(1).mkdir(working\_directory).chdir(working\_directory)

    \_set\_copy\_dirs = batch.Function(workdir, verbose=False) \PYGZbs{}
        .pjoin(input\_directory, "/*").pjoin(working\_directory, "/").cp(\_r, \_r) \PYGZbs{}

    transfer\_infiles = batch.Function(\_set\_copy\_dirs , verbose=False)
        .cp(\_r, \_r).don(1).throw("Failed to transfer files.")

    transfer\_outfiles = batch.Function(\_set\_copy\_dirs, verbose=False) \PYGZbs{}
        .cp(\_, \_).don(1).throw("Failed to transfer files.")

    startjob = batch.Function(workdir) \PYGZbs{}
        .join("(", command, " \textgreater{} .bacthq.output \& echo \$! \textgreater{} .batchq.pid )").send\_command(\_) 

    transfer\_startjob = batch.Function(transfer\_infiles) \PYGZbs{}
        .call(startjob)


    getpid = batch.Function(workdir) \PYGZbs{}
        .cat(".batchq.pid")

    isrunning = batch.Function(get\_pid) \PYGZbs{}
        .isrunning(\_)

    wasstarted = batch.Function(workdir) \PYGZbs{}
        .exists(".batchq.output")

    log = batch.Function(wasstarted) \PYGZbs{}
        .do(1).cat(".batchq.output")

    clean = batch.Function(wasstarted) \PYGZbs{}
        .do(1).rm(".batchq.*", force = True)


Library.queues.register("nohup",NoHUPStart)
if \_\_name\_\_=="\_\_main\_\_":
    dir1 = raw\_input("Enter a input directory: ")
    dir2 = raw\_input("Enter a output directory: ")
    cmd = raw\_input("Enter a command: ")
    x = NoHUPStart(dir1, dir2, cmd)
    
    while True:
        x.interact()
\#    print "1) Transfer input files"
\#    print "2) Submit job"
\#    print "3) Transfer input and submit job"

\#    print "4) Check if it was started"
\#    print "5) Check if it is running"
\#    print "6) Transfer output files"
\#    print "7) Show log"
\#    print "8) Clean up"

\#    print "Q) Quit"
\#    print ""
\#    choice = raw\_input("\# :")
\end{Verbatim}


\section{Full functionality}
\label{tutorial_nhup:full-functionality}

\chapter{Tutorial: LSF Remote Submission}
\label{tutorial_bsub:tutorial-lsf-remote-submission}\label{tutorial_bsub::doc}

\chapter{Remote Jobs using Django}
\label{webinterface:remote-jobs-using-django}\label{webinterface::doc}
The following briefly explains how to put up a local Django webinterface
and how to synchronise it with jobs submitted to a server. No particular
knowledge of Django is required, except if you wish to setup a permanent
web server for keeping track of jobs states.


\section{Dependencies and preliminary notes}
\label{webinterface:dependencies-and-preliminary-notes}
The web interface depends on Django 1.3 (or newer) which can be
obtained using easy\_install as follows

\begin{Verbatim}[commandchars=\\\{\}]
easy\PYGZus{}install django
\end{Verbatim}

The web interface can be located in any directory. We will in the following
assume that it is located in \textasciitilde{}/remoteweb/.


\section{Starting a local server}
\label{webinterface:starting-a-local-server}
Open bash and execute following commands:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{cd} \PYGZti{}/remoteweb/
python manage.py syncdb
python manage.py runserver
\end{Verbatim}

This will start the local web server which can be accessed
on the address \href{http://localhost:8000/}{http://localhost:8000/}. In order to synchronise the jobs
from a given server simply type

\begin{Verbatim}[commandchars=\\\{\}]
python mange.py update\PYGZus{}database \PYG{o}{[}appName \PYG{o}{[}server\PYG{o}{[}:port\PYG{o}{]}\PYG{o}{]}\PYG{o}{]}
\end{Verbatim}

where {[}appName{]} is `remoteJobs-vistrails' if you are using VisTrails with
the standard settings and {[}server{]} is the name of the server. If no
server is supplied the script will assume that you wish to work on the
local machine. If a server name is supplied the script will prompt for
username and password. After entering these the database is updated with
the jobs which has previously been submitted to the server.


\section{Webinterface}
\label{webinterface:webinterface}
In order to access the web interface go to \href{http://localhost:8000/}{http://localhost:8000/} in
your favorite browser. A list of should now appear

which has been optimised for running on mobile units. From the
webinterface you can see the status of your jobs, cancel or
resubmit them. The changes take effect whenever

\begin{Verbatim}[commandchars=\\\{\}]
python mange.py update\PYGZus{}database \PYG{o}{[}appName \PYG{o}{[}server\PYG{o}{[}:port\PYG{o}{]}\PYG{o}{]}\PYG{o}{]}
\end{Verbatim}

has been executed.


\chapter{Remote Jobs with custom database}
\label{webinterface:remote-jobs-with-custom-database}
We will in the following assume that you have a access to a database
with predefined tables and columns. In this part of the document we will
describe how to poll the information from the server and add it to a
database.


\section{Pulling settings entries}
\label{webinterface:pulling-settings-entries}
Pulling the submitted jobs from a server is done using the
RemoteJobSubmitter module.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{remotejobs} \PYG{k+kn}{import} \PYG{n}{RemoteJobSubmitter}
\PYG{k+kn}{import} \PYG{n+nn}{getpass}

\PYG{k}{class} \PYG{n+nc}{Database}\PYG{p}{:}
   \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{   This object will represent our database.}
\PYG{l+s+sd}{   """}
   \PYG{k}{def} \PYG{n+nf}{get\PYGZus{}record}\PYG{p}{(}\PYG{n}{primary\PYGZus{}key}\PYG{p}{)}\PYG{p}{:}
       \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{       This methods returns a record as a dictionary}
\PYG{l+s+sd}{       if it is found in the database and None else.}
\PYG{l+s+sd}{       """}
       \PYG{k}{pass}

   \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n}{primary\PYGZus{}key}\PYG{p}{,} \PYG{n}{record\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
       \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{       This method updates the record with the primary key as}
\PYG{l+s+sd}{       primary\PYGZus{}key by setting key = 'val' for key, val in record\PYGZus{}dict.}
\PYG{l+s+sd}{       """}
       \PYG{k}{pass}

   \PYG{k}{def} \PYG{n+nf}{insert}\PYG{p}{(}\PYG{n}{primary\PYGZus{}key}\PYG{p}{,} \PYG{n}{record\PYGZus{}dict}\PYG{p}{)}\PYG{p}{:}
       \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{       This method inserts a record with the primary key as}
\PYG{l+s+sd}{       primary\PYGZus{}key by setting key = 'val' for key, val in record\PYGZus{}dict.}
\PYG{l+s+sd}{       """}
       \PYG{k}{pass}

\PYG{n}{server} \PYG{o}{=} \PYG{n+nb+bp}{None}
\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{22}
\PYG{n}{username} \PYG{o}{=} \PYG{n}{getpass}\PYG{o}{.}\PYG{n}{getuser}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{password} \PYG{o}{=} \PYG{n}{getpass}\PYG{o}{.}\PYG{n}{getpass}\PYG{p}{(}\PYG{p}{)}

\PYG{c}{\PYGZsh{} We will update to columns in the database: "last\PYGZus{}updated" and "id".}
\PYG{c}{\PYGZsh{} The following dictionary will be used to map the settings entries}
\PYG{c}{\PYGZsh{} into the database column names.}
\PYG{n}{mapping} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{'}\PYG{l+s}{updated}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{last\PYGZus{}updated}\PYG{l+s}{'}\PYG{p}{,} \PYG{l+s}{'}\PYG{l+s}{jobid}\PYG{l+s}{'}\PYG{p}{:} \PYG{l+s}{'}\PYG{l+s}{id}\PYG{l+s}{'}\PYG{p}{\PYGZcb{}}

\PYG{n}{job\PYGZus{}submitter} \PYG{o}{=} \PYG{n}{RemoteJobSubmitter}\PYG{p}{(}\PYG{n}{appName}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{n}{username}\PYG{p}{,} \PYG{n}{password}\PYG{p}{)}
\PYG{n}{jobs} \PYG{o}{=} \PYG{n}{job\PYGZus{}submitter}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{list\PYGZus{}keys}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{db} \PYG{o}{=} \PYG{n}{Database}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{jobid} \PYG{o+ow}{in} \PYG{n}{jobs}\PYG{p}{:}
    \PYG{n+nb}{hash}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{jobid}\PYG{o}{.}\PYG{n}{rsplit}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{\PYGZus{}}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{try}\PYG{p}{:}
      \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}
    \PYG{k}{except}\PYG{p}{:} \PYG{c}{\PYGZsh{} In case the directory contains non-valid settings files}
      \PYG{k}{continue}

    \PYG{c}{\PYGZsh{} Remark it is important to put clean (third argument) to False here}
    \PYG{c}{\PYGZsh{} If this is not set to False any finished job will be deleted.}
    \PYG{n}{record} \PYG{o}{=} \PYG{n}{job\PYGZus{}submitter}\PYG{o}{.}\PYG{n}{check\PYGZus{}state}\PYG{p}{(}\PYG{n+nb}{hash}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n+nb+bp}{False}\PYG{p}{)}

    \PYG{n}{setting\PYGZus{}entries} \PYG{o}{=} \PYG{n+nb}{filter}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{mapping}\PYG{p}{,} \PYG{p}{[}\PYG{n}{key} \PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{records}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cols} \PYG{o}{=} \PYG{p}{[}\PYG{n}{mapping}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]} \PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{setting\PYGZus{}entries}\PYG{p}{]}
    \PYG{n}{vals} \PYG{o}{=} \PYG{p}{[}\PYG{n}{record}\PYG{p}{[}\PYG{n}{key}\PYG{p}{]} \PYG{k}{for} \PYG{n}{key} \PYG{o+ow}{in} \PYG{n}{setting\PYGZus{}entries}\PYG{p}{]}
    \PYG{n}{record\PYGZus{}dict} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{cols}\PYG{p}{,} \PYG{n}{vals}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{db}\PYG{o}{.}\PYG{n}{get\PYGZus{}record}\PYG{p}{(}\PYG{n}{jobid}\PYG{p}{)} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
       \PYG{n}{db}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{jobid}\PYG{p}{,} \PYG{n}{record\PYGZus{}dict}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
       \PYG{n}{db}\PYG{o}{.}\PYG{n}{update}\PYG{p}{(}\PYG{n}{jobid}\PYG{p}{,} \PYG{n}{record\PYGZus{}dict}\PYG{p}{)}
\end{Verbatim}

This code serves as an example and is not recommended to deploy for
pulling the jobs without further optimisations.
The above example will run slowly due to two
reasons:

1. There is made no check whether the database record is up-to-date
meaning that we update records that are all up-to-date every time we
check the status of the jobs.

2. As more an more jobs gets submitted to the server the list of key
entries becomes very large. It can therefore be beneficial to clean the
settings module for any keys that has been marked as cleaned. In order
to so add the following to your

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{TODO}
\end{Verbatim}

cron script.

Be aware that the last optimisation will cause problems if several
databases are updated as a finished job may be deleted before it is pull
into all databases.


\chapter{API Reference}
\label{api:api-reference}\label{api::doc}

\section{Core Pipeline Classes}
\label{api/terminal:core-pipeline-classes}\label{api/terminal::doc}

\subsection{BasePipe}
\label{api/terminal:basepipe}\label{api/terminal:module-batchq.core.communication}\index{batchq.core.communication (module)}
This is some sort of docs??
\index{BasePipe (class in batchq.core.communication)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe}\pysiglinewithargsret{\strong{class }\code{batchq.core.communication.}\bfcode{BasePipe}}{\emph{pipe}, \emph{expect\_token}, \emph{submit\_token}, \emph{mem\_scale=1000.0}, \emph{vt100=None}, \emph{initiate\_pipe=True}}{}~\index{buffer (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.buffer}\pysigline{\bfcode{buffer}}
Contains the VT100 interpreted buffer.

\end{fulllineitems}

\index{child\_memory\_usage (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.child_memory_usage}\pysigline{\bfcode{child\_memory\_usage}}
\end{fulllineitems}

\index{consume\_output() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.consume_output}\pysiglinewithargsret{\bfcode{consume\_output}}{\emph{pipe=None}, \emph{consume\_until=None}}{}
This function consumes output of the pipe which is separated
with no more than 10 ms and returns it.

\end{fulllineitems}

\index{cpu\_usage() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.cpu_usage}\pysiglinewithargsret{\bfcode{cpu\_usage}}{}{}
\end{fulllineitems}

\index{expect() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.expect}\pysiglinewithargsret{\bfcode{expect}}{\emph{val=None}}{}
\end{fulllineitems}

\index{initiate\_pipe() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.initiate_pipe}\pysiglinewithargsret{\bfcode{initiate\_pipe}}{}{}
This function is a virtual function which is called 
at the end if the objects initiation. Its purpose is to initiate
the pipe with a series of commands.

\end{fulllineitems}

\index{kill() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.kill}\pysiglinewithargsret{\bfcode{kill}}{}{}
\end{fulllineitems}

\index{memory\_usage (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.memory_usage}\pysigline{\bfcode{memory\_usage}}
\end{fulllineitems}

\index{pid (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.pid}\pysigline{\bfcode{pid}}
\end{fulllineitems}

\index{pipe (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.pipe}\pysigline{\bfcode{pipe}}
\end{fulllineitems}

\index{pipe\_buffer (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.pipe_buffer}\pysigline{\bfcode{pipe\_buffer}}
Contains the true pipe buffer.

\end{fulllineitems}

\index{pop\_expect() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.pop_expect}\pysiglinewithargsret{\bfcode{pop\_expect}}{}{}
\end{fulllineitems}

\index{pop\_submit() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.pop_submit}\pysiglinewithargsret{\bfcode{pop\_submit}}{}{}
\end{fulllineitems}

\index{push\_expect() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.push_expect}\pysiglinewithargsret{\bfcode{push\_expect}}{\emph{expect\_token}}{}
\end{fulllineitems}

\index{push\_submit() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.push_submit}\pysiglinewithargsret{\bfcode{push\_submit}}{\emph{submit\_token}}{}
\end{fulllineitems}

\index{remaining() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.remaining}\pysiglinewithargsret{\bfcode{remaining}}{}{}
\end{fulllineitems}

\index{send\_command() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.send_command}\pysiglinewithargsret{\bfcode{send\_command}}{\emph{cmd}}{}
This function sends a command to the pipe, wait for the prompt
to appear and return the output.

\end{fulllineitems}

\index{set\_timeout() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.set_timeout}\pysiglinewithargsret{\bfcode{set\_timeout}}{\emph{t}}{}
\end{fulllineitems}

\index{terminate() (batchq.core.communication.BasePipe method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.terminate}\pysiglinewithargsret{\bfcode{terminate}}{}{}
\end{fulllineitems}

\index{total\_memory\_usage (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.total_memory_usage}\pysigline{\bfcode{total\_memory\_usage}}
\end{fulllineitems}

\index{vt100interpreter (batchq.core.communication.BasePipe attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.communication.BasePipe.vt100interpreter}\pysigline{\bfcode{vt100interpreter}}
This property holds an instance of a \code{VT100Interpreter}.

\end{fulllineitems}


\end{fulllineitems}



\subsection{VT100 Terminal Interpreter}
\label{api/terminal:module-batchq.core.terminal}\label{api/terminal:vt100-terminal-interpreter}\index{batchq.core.terminal (module)}\index{PatternRegister (class in batchq.core.terminal)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.PatternRegister}\pysigline{\strong{class }\code{batchq.core.terminal.}\bfcode{PatternRegister}}
This objects is a register for mapping keystrokes into functions. A
keystroke is added using the register method and the function is
retrieved using get\_function.
\index{get\_function() (batchq.core.terminal.PatternRegister method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.PatternRegister.get_function}\pysiglinewithargsret{\bfcode{get\_function}}{\emph{k}}{}
Given a keystroke combination k, this function returns the
registered function. It returns None if no function is found.

\end{fulllineitems}

\index{re (batchq.core.terminal.PatternRegister attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.PatternRegister.re}\pysigline{\bfcode{re}}
This property holds a regex pattern for identifying
keystrokes. The pattern is naive made, and thus, can easily be
optimised. However, the function is provided to enable fast
development.

\end{fulllineitems}

\index{register() (batchq.core.terminal.PatternRegister method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.PatternRegister.register}\pysiglinewithargsret{\bfcode{register}}{\emph{*kwds}}{}
Registers a new keystroke.

\end{fulllineitems}


\end{fulllineitems}

\index{VT100Interpreter (class in batchq.core.terminal)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter}\pysigline{\strong{class }\code{batchq.core.terminal.}\bfcode{VT100Interpreter}}
This object implements VT100 interpretation.
\index{buffer (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.buffer}\pysigline{\bfcode{buffer}}
\end{fulllineitems}

\index{clear\_all\_tabs() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.clear_all_tabs}\pysiglinewithargsret{\bfcode{clear\_all\_tabs}}{}{}
\end{fulllineitems}

\index{clear\_tab() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.clear_tab}\pysiglinewithargsret{\bfcode{clear\_tab}}{}{}
\end{fulllineitems}

\index{copy() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.copy}\pysiglinewithargsret{\bfcode{copy}}{}{}
\end{fulllineitems}

\index{copy\_echo() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.copy_echo}\pysiglinewithargsret{\bfcode{copy\_echo}}{}{}
\end{fulllineitems}

\index{cursor\_back() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_back}\pysiglinewithargsret{\bfcode{cursor\_back}}{\emph{count=1}}{}
\end{fulllineitems}

\index{cursor\_down() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_down}\pysiglinewithargsret{\bfcode{cursor\_down}}{\emph{count=1}}{}
\end{fulllineitems}

\index{cursor\_force\_position() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_force_position}\pysiglinewithargsret{\bfcode{cursor\_force\_position}}{\emph{line}, \emph{char}}{}
\end{fulllineitems}

\index{cursor\_forward() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_forward}\pysiglinewithargsret{\bfcode{cursor\_forward}}{\emph{count=1}}{}
\end{fulllineitems}

\index{cursor\_home() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_home}\pysiglinewithargsret{\bfcode{cursor\_home}}{\emph{line=1}, \emph{char=1}}{}
\end{fulllineitems}

\index{cursor\_restore\_attrs() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_restore_attrs}\pysiglinewithargsret{\bfcode{cursor\_restore\_attrs}}{}{}
\end{fulllineitems}

\index{cursor\_save\_attrs() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_save_attrs}\pysiglinewithargsret{\bfcode{cursor\_save\_attrs}}{}{}
\end{fulllineitems}

\index{cursor\_up() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.cursor_up}\pysiglinewithargsret{\bfcode{cursor\_up}}{\emph{count=1}}{}
\end{fulllineitems}

\index{delete() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.delete}\pysiglinewithargsret{\bfcode{delete}}{}{}
\end{fulllineitems}

\index{disable\_line\_wrap() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.disable_line_wrap}\pysiglinewithargsret{\bfcode{disable\_line\_wrap}}{}{}
\end{fulllineitems}

\index{echo (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.echo}\pysigline{\bfcode{echo}}
\end{fulllineitems}

\index{enable\_line\_wrap() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.enable_line_wrap}\pysiglinewithargsret{\bfcode{enable\_line\_wrap}}{}{}
\end{fulllineitems}

\index{erase\_down() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_down}\pysiglinewithargsret{\bfcode{erase\_down}}{}{}
\end{fulllineitems}

\index{erase\_end\_of\_line() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_end_of_line}\pysiglinewithargsret{\bfcode{erase\_end\_of\_line}}{}{}
\end{fulllineitems}

\index{erase\_line() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_line}\pysiglinewithargsret{\bfcode{erase\_line}}{}{}
\end{fulllineitems}

\index{erase\_screen() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_screen}\pysiglinewithargsret{\bfcode{erase\_screen}}{}{}
\end{fulllineitems}

\index{erase\_start\_of\_line() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_start_of_line}\pysiglinewithargsret{\bfcode{erase\_start\_of\_line}}{}{}
\end{fulllineitems}

\index{erase\_up() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.erase_up}\pysiglinewithargsret{\bfcode{erase\_up}}{}{}
\end{fulllineitems}

\index{escape\_mode (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.escape_mode}\pysigline{\bfcode{escape\_mode}}
\end{fulllineitems}

\index{fix\_buffer() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.fix_buffer}\pysiglinewithargsret{\bfcode{fix\_buffer}}{}{}
\end{fulllineitems}

\index{last\_escape (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.last_escape}\pysigline{\bfcode{last\_escape}}
\end{fulllineitems}

\index{linestart() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.linestart}\pysiglinewithargsret{\bfcode{linestart}}{}{}
\end{fulllineitems}

\index{monitor (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.monitor}\pysigline{\bfcode{monitor}}
\end{fulllineitems}

\index{monitor\_echo (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.monitor_echo}\pysigline{\bfcode{monitor\_echo}}
\end{fulllineitems}

\index{move\_monitor\_cursors() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.move_monitor_cursors}\pysiglinewithargsret{\bfcode{move\_monitor\_cursors}}{}{}
\end{fulllineitems}

\index{newline() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.newline}\pysiglinewithargsret{\bfcode{newline}}{}{}
\end{fulllineitems}

\index{put() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.put}\pysiglinewithargsret{\bfcode{put}}{\emph{c}}{}
\end{fulllineitems}

\index{readable\_echo (batchq.core.terminal.VT100Interpreter attribute)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.readable_echo}\pysigline{\bfcode{readable\_echo}}
\end{fulllineitems}

\index{reset\_device() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.reset_device}\pysiglinewithargsret{\bfcode{reset\_device}}{}{}
\end{fulllineitems}

\index{scroll\_constrain() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.scroll_constrain}\pysiglinewithargsret{\bfcode{scroll\_constrain}}{}{}
\end{fulllineitems}

\index{scroll\_down() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.scroll_down}\pysiglinewithargsret{\bfcode{scroll\_down}}{}{}
\end{fulllineitems}

\index{scroll\_screen() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.scroll_screen}\pysiglinewithargsret{\bfcode{scroll\_screen}}{}{}
\end{fulllineitems}

\index{scroll\_screen\_rows() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.scroll_screen_rows}\pysiglinewithargsret{\bfcode{scroll\_screen\_rows}}{\emph{rs}, \emph{re}}{}
\end{fulllineitems}

\index{scroll\_up() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.scroll_up}\pysiglinewithargsret{\bfcode{scroll\_up}}{}{}
\end{fulllineitems}

\index{set\_alt\_font() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_alt_font}\pysiglinewithargsret{\bfcode{set\_alt\_font}}{}{}
\end{fulllineitems}

\index{set\_default\_font() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_default_font}\pysiglinewithargsret{\bfcode{set\_default\_font}}{}{}
\end{fulllineitems}

\index{set\_display\_attr() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_display_attr}\pysiglinewithargsret{\bfcode{set\_display\_attr}}{\emph{attributes}}{}
\end{fulllineitems}

\index{set\_mark() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_mark}\pysiglinewithargsret{\bfcode{set\_mark}}{}{}
\end{fulllineitems}

\index{set\_mode() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_mode}\pysiglinewithargsret{\bfcode{set\_mode}}{\emph{mode}, \emph{property}}{}
\end{fulllineitems}

\index{set\_tab() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.set_tab}\pysiglinewithargsret{\bfcode{set\_tab}}{}{}
\end{fulllineitems}

\index{unknown1() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.unknown1}\pysiglinewithargsret{\bfcode{unknown1}}{}{}
\end{fulllineitems}

\index{write() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.write}\pysiglinewithargsret{\bfcode{write}}{\emph{str}}{}
\end{fulllineitems}

\index{writeChar() (batchq.core.terminal.VT100Interpreter method)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.VT100Interpreter.writeChar}\pysiglinewithargsret{\bfcode{writeChar}}{\emph{c}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{convert\_to\_int() (in module batchq.core.terminal)}

\begin{fulllineitems}
\phantomsection\label{api/terminal:batchq.core.terminal.convert_to_int}\pysiglinewithargsret{\code{batchq.core.terminal.}\bfcode{convert\_to\_int}}{\emph{x}}{}
\end{fulllineitems}



\section{Shell Pipelines}
\label{api/shell_terminals::doc}\label{api/shell_terminals:shell-pipelines}
BatchQ comes with a number of predefined pipelines. Included in these
are three shells, \code{BashTerminal}, \code{SSHTerminal} and
\code{SFTPTerminal}, and one shell based class \code{FileCommander}.


\subsection{Bash terminal}
\label{api/shell_terminals:bash-terminal}\label{api/shell_terminals:module-batchq.pipelines.shell.bash}\index{batchq.pipelines.shell.bash (module)}\index{BashTerminal (class in batchq.pipelines.shell.bash)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.bash.}\bfcode{BashTerminal}}{\emph{pipe=None}, \emph{expect\_token='\#--\textgreater{}'}, \emph{submit\_token='n'}, \emph{path\_module=None}, \emph{initiate\_pipe=True}}{}
Unless another pipe is supplied this constructor opens bash and
sets the path module along with the expectation token and the
submit token. The expectation token is the prompt characters and should be
chosen such that one would not expect it to appear in any output
of any of the executed programs. The token is set in
\code{BashTerminal.initiate\_pipe()} which is called if \code{initiate\_pipe
= True} (default). The submit token is the token that will be send
to the pipe after the command has been sent and the command echo has been
consumed. For a normal bash terminal this is simply \code{\textbackslash{}n}.
\index{cat() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.cat}\pysiglinewithargsret{\bfcode{cat}}{\emph{filename}}{}
Returns the contents of a file.

\end{fulllineitems}

\index{chdir() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.chdir}\pysiglinewithargsret{\bfcode{chdir}}{\emph{dir}}{}
Changes the current working directory into dir.

\end{fulllineitems}

\index{command\_exists() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.command_exists}\pysiglinewithargsret{\bfcode{command\_exists}}{\emph{path}}{}
Checks whether a commmand exists in the environment path or not.

\end{fulllineitems}

\index{cp() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.cp}\pysiglinewithargsret{\bfcode{cp}}{\emph{source}, \emph{dest}, \emph{recursively=False}}{}
Copies source to dest. If recursive is set to True directories
are recursively copied.

\end{fulllineitems}

\index{directory\_hash() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.directory_hash}\pysiglinewithargsret{\bfcode{directory\_hash}}{\emph{dir}}{}
\end{fulllineitems}

\index{dirname() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.dirname}\pysiglinewithargsret{\bfcode{dirname}}{\emph{object}}{}
This function tries to retrieve the directory name of object and
resolve all symlinks.

\end{fulllineitems}

\index{echo() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.echo}\pysiglinewithargsret{\bfcode{echo}}{\emph{msg}, \emph{output=None}}{}
Echo a message to output. If output is None, then echo is undirected.

\end{fulllineitems}

\index{exists() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.exists}\pysiglinewithargsret{\bfcode{exists}}{\emph{path}}{}
Returns \code{True} if \code{path} is either a directory or a file.

\end{fulllineitems}

\index{file\_hash() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.file_hash}\pysiglinewithargsret{\bfcode{file\_hash}}{\emph{filename}, \emph{check\_file=True}}{}
\end{fulllineitems}

\index{format\_path() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.format_path}\pysiglinewithargsret{\bfcode{format\_path}}{\emph{path}}{}
\end{fulllineitems}

\index{hash() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.hash}\pysiglinewithargsret{\bfcode{hash}}{\emph{path}}{}
\end{fulllineitems}

\index{hasher (batchq.pipelines.shell.bash.BashTerminal attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.hasher}\pysigline{\bfcode{hasher}}
This property returns a tuple containing the bash command for
doing a hash, the corresponding Python routine (as string) and a
regex pattern that matches the hash.

\end{fulllineitems}

\index{home() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.home}\pysiglinewithargsret{\bfcode{home}}{}{}
\end{fulllineitems}

\index{initiate\_pipe() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.initiate_pipe}\pysiglinewithargsret{\bfcode{initiate\_pipe}}{}{}
This function evaluates the commands that will be unique for our
bash session. This functions changes the promt such that it will
be the same independently of the user.

\end{fulllineitems}

\index{isdir() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.isdir}\pysiglinewithargsret{\bfcode{isdir}}{\emph{dir}}{}
Returns \code{True} if \code{dir} is a directory.

\end{fulllineitems}

\index{isfile() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.isfile}\pysiglinewithargsret{\bfcode{isfile}}{\emph{filename}}{}
Returns \code{True} if \code{filename} is a file.

\end{fulllineitems}

\index{isrunning() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.isrunning}\pysiglinewithargsret{\bfcode{isrunning}}{\emph{pid}}{}
Returns \code{True} if the \code{pid} is found in the systems process list.

\end{fulllineitems}

\index{last\_exitcode() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.last_exitcode}\pysiglinewithargsret{\bfcode{last\_exitcode}}{}{}
Returns the exit code of the last started proccess. If this is
not possible \code{None} is returned.

\end{fulllineitems}

\index{last\_modified() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.last_modified}\pysiglinewithargsret{\bfcode{last\_modified}}{\emph{path}}{}
This function returns the last modification time of the given
directory or file.

\end{fulllineitems}

\index{last\_pid() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.last_pid}\pysiglinewithargsret{\bfcode{last\_pid}}{}{}
Returns the pid of the last started proccess. If this is
not possible 0 is returned.

\end{fulllineitems}

\index{list() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.list}\pysiglinewithargsret{\bfcode{list}}{\emph{dir='.'}, \emph{recursively=True}}{}
List files in directory.

Warning! If recursively is True, all subdirectories are included
(also hidden ones, i.e. staring with `.'). Consequently, this
command will execute extremely slowly if many levels of
recursion occur.

\end{fulllineitems}

\index{mkdir() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.mkdir}\pysiglinewithargsret{\bfcode{mkdir}}{\emph{dir}, \emph{create\_intermediate=False}}{}
\end{fulllineitems}

\index{path (batchq.pipelines.shell.bash.BashTerminal attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.path}\pysigline{\bfcode{path}}
This function returns the path object for the system on which
the terminal runs. This function is
implemented as a matter of convience as different terminals may
be based on different standards. You can for instance not rely on
os.path when controlling SSH from a Windows machine.

\end{fulllineitems}

\index{popd() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.popd}\pysiglinewithargsret{\bfcode{popd}}{}{}
\end{fulllineitems}

\index{pushd() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.pushd}\pysiglinewithargsret{\bfcode{pushd}}{\emph{dir}}{}
Changes the current working directory into dir.

\end{fulllineitems}

\index{pwd() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.pwd}\pysiglinewithargsret{\bfcode{pwd}}{}{}
\end{fulllineitems}

\index{rm() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.rm}\pysiglinewithargsret{\bfcode{rm}}{\emph{path}, \emph{force=False}, \emph{recursively=False}}{}
Removes the path on the file system.

\end{fulllineitems}

\index{set\_permission() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.set_permission}\pysiglinewithargsret{\bfcode{set\_permission}}{\emph{file}, \emph{permissions}}{}
\end{fulllineitems}

\index{whoami() (batchq.pipelines.shell.bash.BashTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.bash.BashTerminal.whoami}\pysiglinewithargsret{\bfcode{whoami}}{}{}
Invokes \code{whoami} in the terminal and returns the result.

\end{fulllineitems}


\end{fulllineitems}



\subsection{SSH terminal}
\label{api/shell_terminals:module-batchq.pipelines.shell.ssh}\label{api/shell_terminals:ssh-terminal}\index{batchq.pipelines.shell.ssh (module)}\index{BaseSecureTerminal (class in batchq.pipelines.shell.ssh)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.ssh.BaseSecureTerminal}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.ssh.}\bfcode{BaseSecureTerminal}}{\emph{server}, \emph{username}, \emph{password}, \emph{port=22}, \emph{accept\_figerprint=False}, \emph{command='ssh'}, \emph{port\_option='-p \%d'}, \emph{expect\_token='\#--\textgreater{}'}, \emph{submit\_token='n'}}{}
\end{fulllineitems}

\index{BaseSecureTerminalLoginError}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.ssh.BaseSecureTerminalLoginError}\pysigline{\strong{exception }\code{batchq.pipelines.shell.ssh.}\bfcode{BaseSecureTerminalLoginError}}
This exception is thrown by secure terminals whenever login attempts
has failed or when acceptence of fingerprints is required but not
allowed.

\end{fulllineitems}

\index{SSHTerminal (class in batchq.pipelines.shell.ssh)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.ssh.SSHTerminal}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.ssh.}\bfcode{SSHTerminal}}{\emph{server}, \emph{username}, \emph{password}, \emph{port=22}, \emph{accept\_figerprint=False}}{}
The object will be initiated as first as a BaseSecureTerminal and
secondly as a BashTerminal. The order of the inheritance is important
as the constructor which is called first will open the pipe
(i.e. either SSH or Bash). Moreover, the SSHTerminal inherits
all the functionality of the bash terminal (which makes sense as it
just is a remote bash terminal after successful login).

Following code gives an example of how the SSH Terminal may be used
to pull out a list of files and directories:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{getpass}
\PYG{n}{server} \PYG{o}{=} \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Server:}\PYG{l+s}{"}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{server} \PYG{o}{==} \PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{:} \PYG{n}{server} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{localhost}\PYG{l+s}{"}
\PYG{n}{username} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{"}
\PYG{k}{while} \PYG{n}{username} \PYG{o}{==} \PYG{l+s}{"}\PYG{l+s}{"}\PYG{p}{:}  \PYG{n}{username} \PYG{o}{=} \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Username:}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{pas} \PYG{o}{=} \PYG{n}{getpass}\PYG{o}{.}\PYG{n}{getpass}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{SSHTerminal}\PYG{p}{(}\PYG{n}{server}\PYG{p}{,} \PYG{n}{username}\PYG{p}{,} \PYG{n}{pas}\PYG{p}{)}

\PYG{n}{files}\PYG{p}{,} \PYG{n}{dirs} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{list}\PYG{p}{(}\PYG{n}{recursively} \PYG{o}{=} \PYG{n+nb+bp}{False}\PYG{p}{)}
\PYG{n}{pwd} \PYG{o}{=} \PYG{n}{x}\PYG{o}{.}\PYG{n}{pwd}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{On}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{is following files }\PYG{l+s}{"}
\PYG{k}{for} \PYG{n+nb}{file} \PYG{o+ow}{in} \PYG{n}{files}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{     -}\PYG{l+s}{"}\PYG{p}{,} \PYG{n+nb}{file}

\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{and following directories}\PYG{l+s}{"}
\PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{dirs}\PYG{p}{:}
   \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{     -}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{d}\PYG{p}{,}\PYG{l+s}{"}\PYG{l+s}{.}\PYG{l+s}{"}

\PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{in}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{pwd}
\end{Verbatim}

\end{fulllineitems}



\subsection{SFTP terminal}
\label{api/shell_terminals:sftp-terminal}\label{api/shell_terminals:module-batchq.pipelines.shell.sftp}\index{batchq.pipelines.shell.sftp (module)}\index{SFTPTerminal (class in batchq.pipelines.shell.sftp)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.sftp.}\bfcode{SFTPTerminal}}{\emph{server}, \emph{username}, \emph{password}, \emph{port=22}, \emph{accept\_figerprint=False}}{}~\index{chdir() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.chdir}\pysiglinewithargsret{\bfcode{chdir}}{\emph{path}}{}
\end{fulllineitems}

\index{getfile() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.getfile}\pysiglinewithargsret{\bfcode{getfile}}{\emph{local\_file}, \emph{remote\_file}}{}
\end{fulllineitems}

\index{initiate\_pipe() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.initiate_pipe}\pysiglinewithargsret{\bfcode{initiate\_pipe}}{}{}
\end{fulllineitems}

\index{local\_chdir() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.local_chdir}\pysiglinewithargsret{\bfcode{local\_chdir}}{\emph{path}}{}
\end{fulllineitems}

\index{local\_pwd() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.local_pwd}\pysiglinewithargsret{\bfcode{local\_pwd}}{}{}
\end{fulllineitems}

\index{pwd() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.pwd}\pysiglinewithargsret{\bfcode{pwd}}{}{}
\end{fulllineitems}

\index{sendfile() (batchq.pipelines.shell.sftp.SFTPTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.sftp.SFTPTerminal.sendfile}\pysiglinewithargsret{\bfcode{sendfile}}{\emph{local\_file}, \emph{remote\_file}}{}
\end{fulllineitems}


\end{fulllineitems}



\subsection{FileCommander}
\label{api/shell_terminals:filecommander}\label{api/shell_terminals:module-batchq.pipelines.shell.utils}\index{batchq.pipelines.shell.utils (module)}\index{FileCommander (class in batchq.pipelines.shell.utils)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.utils.}\bfcode{FileCommander}}{\emph{server=None}, \emph{username='`}, \emph{password='`}, \emph{port=22}, \emph{accept\_figerprint=False}}{}
FileCommander provides an easy-to-use interface for transfering 
files as well as access both the local and the remote file system. It 
performs common operations such compare directories in the local and
remote views as well as syncronising them.

The local and remote terminals can be access through the property
FileCommander.local and FileCommander.remote, respectively, which
are both instances of the BashTerminal.
\index{MODE\_LOCAL\_REMOTE (batchq.pipelines.shell.utils.FileCommander attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.MODE_LOCAL_REMOTE}\pysigline{\bfcode{MODE\_LOCAL\_REMOTE}\strong{ = 1}}
\end{fulllineitems}

\index{MODE\_REMOTE\_LOCAL (batchq.pipelines.shell.utils.FileCommander attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.MODE_REMOTE_LOCAL}\pysigline{\bfcode{MODE\_REMOTE\_LOCAL}\strong{ = 2}}
\end{fulllineitems}

\index{diff() (batchq.pipelines.shell.utils.FileCommander method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.diff}\pysiglinewithargsret{\bfcode{diff}}{\emph{local\_dir='.'}, \emph{remote\_dir='.'}, \emph{recursive=True}, \emph{mode=3}, \emph{absolute\_path=False}, \emph{ignore\_hidden=True}}{}
Compare local and remote directories, recursively \code{recursive =
True} (default),  by computing a hash of each file.  
Depending on wether \code{mode} is set to
\code{FileCommander.MODE\_LOCAL\_REMOTE} or \code{FileCommander.MODE\_REMOTE\_LOCAL}  
two lists are returned with files and directories that are
out-of-date, or missing. As standard, hidden files are
ignored. To include hidden files  set \code{ignore\_hidden =
False}. By default, paths returned are relative, but if
\code{absolute\_path = True} they are converted into absolute paths.

\end{fulllineitems}

\index{local (batchq.pipelines.shell.utils.FileCommander attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.local}\pysigline{\bfcode{local}}
This property returns an instance of \code{BashTerminal}.

\end{fulllineitems}

\index{remote (batchq.pipelines.shell.utils.FileCommander attribute)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.remote}\pysigline{\bfcode{remote}}
This property returns an instance of \code{SSHTerminal} connected
to the remote machine if server was different than \code{None} in
the constructor. Otherwise, an instance of \code{BashTerminal} is returned.

\end{fulllineitems}

\index{sync() (batchq.pipelines.shell.utils.FileCommander method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileCommander.sync}\pysiglinewithargsret{\bfcode{sync}}{\emph{local\_dir='.'}, \emph{remote\_dir='.'}, \emph{recursive=True}, \emph{mode=3}, \emph{ignore\_hidden=True}}{}
This function compares a local and a remote directory and
transfer missing files in one direction depending on the mode
(which can either be \code{FileCommander.MODE\_LOCAL\_REMOTE} or
\code{FileCommander.MODE\_REMOTE\_LOCAL}). Note this function ignores the
creation/modification date of the file or directory.

\end{fulllineitems}


\end{fulllineitems}

\index{FileTransferTerminal (class in batchq.pipelines.shell.utils)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal}\pysiglinewithargsret{\strong{class }\code{batchq.pipelines.shell.utils.}\bfcode{FileTransferTerminal}}{\emph{server=None}, \emph{username='`}, \emph{password='`}, \emph{port=22}, \emph{accept\_figerprint=False}}{}
This object is similar to SFTPTerminal if server, username and
password are passed to the constructor. If server=None, this class
implements the SFTPTerminal operations for the for local file
system. Wether a FileTransferTerminal class is working on the local
filesystem or not can be checked with FileTransferTerminal.islocal().
\index{chdir() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.chdir}\pysiglinewithargsret{\bfcode{chdir}}{\emph{path}}{}
\end{fulllineitems}

\index{getfile() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.getfile}\pysiglinewithargsret{\bfcode{getfile}}{\emph{local\_file}, \emph{remote\_file}}{}
\end{fulllineitems}

\index{islocal() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.islocal}\pysiglinewithargsret{\bfcode{islocal}}{}{}
\end{fulllineitems}

\index{local\_chdir() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.local_chdir}\pysiglinewithargsret{\bfcode{local\_chdir}}{\emph{path}}{}
\end{fulllineitems}

\index{local\_pwd() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.local_pwd}\pysiglinewithargsret{\bfcode{local\_pwd}}{}{}
\end{fulllineitems}

\index{pwd() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.pwd}\pysiglinewithargsret{\bfcode{pwd}}{}{}
\end{fulllineitems}

\index{sendfile() (batchq.pipelines.shell.utils.FileTransferTerminal method)}

\begin{fulllineitems}
\phantomsection\label{api/shell_terminals:batchq.pipelines.shell.utils.FileTransferTerminal.sendfile}\pysiglinewithargsret{\bfcode{sendfile}}{\emph{local\_file}, \emph{remote\_file}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{Math Terminals}
\label{api/math_terminals:math-terminals}\label{api/math_terminals::doc}

\section{Batch Model}
\label{api/batch::doc}\label{api/batch:module-batchq.core.batch}\label{api/batch:batch-model}\index{batchq.core.batch (module)}\index{BaseField (class in batchq.core.batch)}

\begin{fulllineitems}
\phantomsection\label{api/batch:batchq.core.batch.BaseField}\pysigline{\strong{class }\code{batchq.core.batch.}\bfcode{BaseField}}
The base field is the base class for fields in a BatchQ model.

\end{fulllineitems}

\index{BatchQ (class in batchq.core.batch)}

\begin{fulllineitems}
\phantomsection\label{api/batch:batchq.core.batch.BatchQ}\pysiglinewithargsret{\strong{class }\code{batchq.core.batch.}\bfcode{BatchQ}}{\emph{*args}, \emph{**kwargs}}{}
The BatchQ object is the ancestor to a specific BatchQ model.

\end{fulllineitems}

\index{Property (class in batchq.core.batch)}

\begin{fulllineitems}
\phantomsection\label{api/batch:batchq.core.batch.Property}\pysiglinewithargsret{\strong{class }\code{batchq.core.batch.}\bfcode{Property}}{\emph{*args}, \emph{**kwargs}}{}
Defines a property of an instance of BatchQ.

\end{fulllineitems}


Indices and tables


\bigskip\hrule{}\bigskip

\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{b}
\item {\texttt{batchq.core.batch}}, \pageref{api/batch:module-batchq.core.batch}
\item {\texttt{batchq.core.communication}}, \pageref{api/terminal:module-batchq.core.communication}
\item {\texttt{batchq.core.terminal}}, \pageref{api/terminal:module-batchq.core.terminal}
\item {\texttt{batchq.pipelines.shell.bash}}, \pageref{api/shell_terminals:module-batchq.pipelines.shell.bash}
\item {\texttt{batchq.pipelines.shell.sftp}}, \pageref{api/shell_terminals:module-batchq.pipelines.shell.sftp}
\item {\texttt{batchq.pipelines.shell.ssh}}, \pageref{api/shell_terminals:module-batchq.pipelines.shell.ssh}
\item {\texttt{batchq.pipelines.shell.utils}}, \pageref{api/shell_terminals:module-batchq.pipelines.shell.utils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
